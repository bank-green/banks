import unittest

from bankreg import BankReg
from testutils import banktrack1, banktrack2, banktrack3, ran1, ran2, ran3, ran4, gabv1
from bank import Bank
from maps.name_tag_map import name_tag_map

class TestBankRegClass(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        BankReg.__instance__ = None
        cls.bankreg = BankReg()

    def test_registry(self):
        self.assertEqual(self.bankreg.reg, {})

    def test_singleton(self):
        # test to make sure it raises an error if instantiated twice
        self.assertRaises(Exception, lambda: BankReg())

class TestSingleBankRegistration(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        BankReg.__instance__ = None
        cls.bankreg = BankReg()
        cls.bankreg.create_or_update_bank(source=banktrack1)

    def test_name(self):
        self.assertEqual(self.bankreg.reg[banktrack1.tag].name, banktrack1.name)


class TestDuplicateBankRegistration(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        BankReg.__instance__ = None
        cls.bankreg = BankReg()

        cls.bankreg.create_or_update_bank(source=banktrack1)
        cls.bankreg.create_or_update_bank(source=ran3)

    def test_only_one_bank(self):
        self.assertEqual(len(self.bankreg.reg.keys()), 1)

    def test_name(self):
        self.assertEqual(self.bankreg.reg[banktrack1.tag].name, ran3.name)

    def test_countries_are_unified(self):
        bank_key = [x for x in self.bankreg.reg.keys()][0]
        expected_countries = sorted(ran3.countries.union(banktrack1.countries))
        self.assertEqual(
            expected_countries, self.bankreg.reg[bank_key].countries)


class TestNewRanRegistration(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        BankReg.__instance__ = None
        cls.bankreg = BankReg()
        cls.bankreg.create_or_update_bank(source=ran1)
        cls.bank_tag = [x for x in cls.bankreg.reg.keys()][0]

    def test_bank_inserted_into_registry(self):
        self.assertEqual(len(self.bankreg.reg.keys()), 1)

    def test_tag_autogenerated_correctly(self):
        self.assertEqual(self.bank_tag, 'bocc_name')

    def test_countries_are_unified(self):
        bank_key = [x for x in self.bankreg.reg.keys()][0]
        expected_countries = sorted(ran1.countries)
        self.assertEqual(
            expected_countries, self.bankreg.reg[bank_key].countries)


class TestSingleRanSantander(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        BankReg.__instance__ = None
        cls.bankreg = BankReg()
        cls.bankreg.create_or_update_bank(source=ran4)

    def test_nametag_map_is_used(self):
        bank_tag = [x for x in self.bankreg.reg.keys()][0]
        self.assertEqual(bank_tag, name_tag_map[ran4.name])


class TestDuplicateSantanderWithMismatchedNames(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        BankReg.__instance__ = None
        cls.bankreg = BankReg()
        cls.bankreg.create_or_update_bank(source=banktrack3)
        cls.bankreg.create_or_update_bank(source=ran4)
        cls.bankreg.create_or_update_bank(source=gabv1)

    def test_banks_with_somewhat_different_names_are_merged_due_to_namemap(self):
        bank_tags = [x for x in self.bankreg.reg.keys()]
        bank = self.bankreg.reg[bank_tags[0]]
        expected_name_list = sorted(set([banktrack3.name.lower(), ran4.name.lower()]))
        self.assertEqual(len(bank_tags), 1)
        self.assertEqual(bank.names, expected_name_list)
        self.assertEqual(bank.gabv.website, 'http://gabvSantander.com')
# if bank already exists, then the gabv information should be added.
# if bank doesn't exist then create the new gabv bank

# Banco Etica is in both gabv, banktrac

# Gabv_website is a unique field for GABV.


if __name__ == '__main__':
    unittest.main()
